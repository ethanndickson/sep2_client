\chapter{Implementation Design}\label{ch:implementation}
Given the context and background surrounding the IEEE 2030.5 Protocol, we can begin examining the considerations taken when designing our implementation.

\section{Programming Language}
The operating context of IEEE 2030.5 greatly influences the software development tools that are suitable for implementation.
When choosing a programming language, we must consider:

\begin{itemize}
    \item \textbf{Device resource constraints} - Many existing IEEE 2030.5 compliant devices are constrained by the clockspeed of the onboard CPU, and the amount of onboard memory.
    For example, the "Gen5 Riva" smart meter by Itron, possesses a 600Mhz processor, and 256Mb of RAM.\cite[]{Gen5Riva}
    \hfill \break
    Therefore, we desire a programming language with minimal runtime overhead, and low-cost abstractions.
    \item \textbf{Cross-platform capabilities} - Given that our client may be deployed on embedded hardware, writing code in a language that can be compiled to a wider range of CPU and hardware configurations is desirable. 
    For this reason, we saw EPRI choose to implement their client in the C programming language.
    \item \textbf{Security} - In 2019, Microsoft attributed 70\% of all CVEs in software to be caused by memory safety issues, in the last 12 years. \cite[]{SecurityMemorySafety}
    As we've previously established improving the security of end user energy devices is part of the core rationale behind IEEE 2030.5. For that reason, developing our client in a language that is memory safe would work towards this goal.
    \item \textbf{Concurrent programming support} - By nature of the protocol, an IEEE 2030.5 client is an I/O bound application. For that reason, we desire a programming language that provides us with abstractions for event-driven architecture, such that operations can be performed while waiting on I/O, even on a single threaded device.
\end{itemize}


\subsection{Rust}
The Rust programming language is a high-level, general purpose programming language that has been strongly influenced by the successes of other programming languages, both industrial and academic
Rust will be used to develop our IEEE 2030.5 client implementation as it addresses all the aforementioned considerations.

\begin{itemize}
    \item Rust provides us with high-level abstractions, but with a focus on performance, and only 'paying' (in terms of available computer resources) for what you use. For that reason, Rust has seen usage in both application and systems level programming.
    \item Although Rust is by no means a universal programming language like C, it has a growing presence in embedded development, and as such has a reasonable degree of portability.
    \item While writing a variation of Rust called 'safe' Rust, the programming language is, outside of compiler bugs, completely memory safe, without the runtime overhead of a garbage collector. When writing 'unsafe' rust, raw pointers may be dereferenced, where by the compiler is no longer able to guarantee memory safety. For that reason, our implementation will be done using purely safe Rust.
    \item Through it's type system, Rust also eliminates the possibility of a data race when working with multiple threads of execution. Furthermore, Rust has native support for asynchronous programming, with concurrency-runtime-independent await and async syntax.
\end{itemize}

Rust's high-level abstractions furthermore lend themselves to the imposed reliability of the client, in that all expected errors are to be handled at compile-time. The Rust algebraic sum types 'Option' and 'Result' enable programmers to handle errors, in order to use the output of a process.
This is contrasted to a language like C++, where runtime exceptions are used to denote errors in the standard library, of which the language does not force the programmer to handle at compile-time.

\section{Operating System}
Despite the desire to write code that is portable, we will nonetheless require operating-system-specific functionality, and as such will need to target a single operating system. Then, we can provide an interface for device manufacturers to swap out should they want to use the client on a different operating system.

Of great consideration when choosing an operating system is the aforementioned 'Aggregator' model for IEEE 2030.5, where by our client would be deployed on a dedicated server, or in the cloud. In this circumstance, it's very much likely an operating system running on the Linux kernel is to be used, due to it's prevalence in server operating-systems.
Whilst there exist purpose built IOT-device operating systems, they are built and optimised for low-spec low-power usage devices, and as such would not be appropriate at scale such as under this model.

Furthermore, there exist very lightweight Linux based operating systems for low-spec devices, making Linux the best choice for our targeted operating system.

\section{Common Library}
As discussed, the IEEE 2030.5 specification makes no distinction between clients \& servers, aside from the fact that servers expose resources, and clients interact with resources. 
For that reason, our client implementation will also produce a common library, that would be used one by developing a IEEE 2030.5 server implementation in Rust.

In this context, it's reasonable to draw inspiration from the EPRI implementation of an IEEE 2030.5 client, and define a series of interfaces that make use of OS specific APIs, such that a device manufacturer need only re-implement those interfaces when porting our software to a different OS.

\subsection{Resource Data Types}
The most important, and largest part of this common library is the internal representation of resources, the data communicated between client \& server. These resources are described precisely in an XSD.
Resources range from data that may be used by the electric utility, such as the current load of the device, to resource metadata, such as the rate at which a client should poll a server for a given resource, or what URI endpoint can be used to access a given resource, in the case of a Link resource.
In both specification and schema, these data structures are separated into packages, and sub-packages. 

Whilst the 2030.5 specification makes no mention of the object oriented programming paradigm, OOP inheritance underpins the design of all resources, including both multi-level and hierarchial inheritance.
As such, for the purpose of code reuse, many base types appear in the 'common' package; data structures extended by many others.

\subsubsection{Representing Resources in Rust}
Rust, despite being influenced by OOP, does not posses the notion of a class, like in languages like C++ or Java, and as such does not define shared behaviour of types through inheritance from a common parent type. 
Rather, Rust defines shared behaviour through traits, where shared behaviour refers solely to the methods that we can call on that type, as per the traits a type implements.
In this sense, Rust does not concern itself with what a type is or what that type stores, it concerns itself only with the traits a type possesses.

Traits themselves do support inheritance. One can have traits that require other traits to be implemented for a given type. However, this does not change the fact that traits only represent behaviour. 
There is no way to have a data structure inherit the internal members of another.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            pub trait Resource {
                fn get_href(&self) -> Option<&str>;
            }
        \end{lstlisting}
        \caption{A Rust trait representing the IEEE 2030.5 "Resource" data type}
    \end{center}
\end{figure}



\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            pub trait List : Resource {
                fn all(&self) -> UInt32;
                fn results(&self) -> UInt32;
            }
        \end{lstlisting}
        \caption{A Rust trait representing the IEEE 2030.5 \texttt{List} data type}
    \end{center}
\end{figure}

In Figure 5.2, we have a Rust trait that describes the behaviour of the List base type. All lists are resources, and thus we have a trait restriction that all types implementing List must first implement the Resource trait.

This is the extent of native inheritance in rust. We can specify the exact behaviour of types that belong to a trait in detail, but we cannot influence how that behaviour is achieved.

\subsubsection{Emulating inheritance in Rust}

As a result, we're forced to emulate the inheritance of data structure members in Rust, of which there are two approaches:

\begin{itemize}
    \item Composite an instance of the base type into type definitions 
    \item Repeat all inherited members in type definitions
\end{itemize}

Regardless of the approach, we still do not have have polymorphism using the base-types of resources.
To allow for polymorphism a trait must be defined for each base-type, and then those trait functions need be implemented for every type that extends the base type. 
This is unavoidable duplicate code, not ignoring the possibility of generating said code.
The extent to which polymorphism is required in the final client implementation is yet to be determined. In this case, we can refer to the EPRI client implementation, 
where they provide device manufacturers an interface for handling resources using polymorphism.
Thus, when determining how we will emulate inheritance, we let the ease at which polymorphism can be allowed influence our decision


\subsubsection{Inheritance via Composition}

If we were to implement the first of the two approaches, we can make use of an existing Rust library to reduce the amount of boilerplate required to implement polymorphism.
This library operates on the basis that inheritance can be replicated via composition. If a data type were to contain a member that implements a given trait, there is no reason for that outer struct to not be able to implement that trait by simply calling upon the underlying member.


\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[inheritable]
            pub trait Resource {
                fn get_href(&self) -> Option<&str>;
            }

            pub struct ResourceObj {
                href: Option<String>
            }

            impl Resource for ResourceObj {
                fn href(&self) -> Option<&str> {
                    self.href.as_str()
                }
            }
        \end{lstlisting}
        \label{fig:resinher}
        \caption{The Rust code required to represent the IEEE 2030.5 "Resource" data type using 'inheritance-rs'}
    \end{center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[derive(Inheritance)]
            pub struct List {
                #[inherits(Resource)]
                res: ResourceObj,
                all: UInt32,
                results: UInt32,
            }
        \end{lstlisting}
        \label{fig:listinher}
        \caption{A Rust data type representing an IEEE 2030.5 \texttt{List} using 'inheritance-rs'}
    \end{center}
\end{figure}


Figures 5.3 and 5.4 show how this library, 'inheritance-rs' \cite[]{inheritancers} is used to reduce the boilerplate necessary to inherit data members. 
In Figure 5.3, we mark the Resource trait as 'inheritable' and then implement that trait on a type that holds the necessary members, our bare minimum 'base' type. 
In Figure 5.3, we compose an instance of that base type into a type that would normally inherit from it. Then, we tell the library to generate the code, at compile-time, that would allow List to implement the Resource trait.
This generated code simply calls the underlying ResourceObj member when the href function would be called on a list.

The major flaw in this approach is that for every single type that is used as a base type, a trait, and a base implementation of that trait needs to be written.
Given that there are just under 700 data types in the IEEE 2030.5 specification schema, we must consider alternatives.


\subsubsection{XSD to Rust types}

If we were to implement the second approach, an existing Rust library can be used to automate the process of defining data types altogether.
This of course draws on the fact that the IEEE 2030.5 XSD is entirely self-contained, and follows XSD guidelines by W3C. As such, generating rust data types from it is a reasonable approach.
One such way to automate this process would be to design and implement our own XSD parser, however, we are not the first to require this tool. 

On the Rust public crates registry there are several XSD parsers, many of which existing to solve very similar problems; implementing standardised communication protocols in Rust.
However, for that reason, many of these implementations are developed until they meet the creators needs, at which point the tool is no longer maintained.

Of the most complete parsers, one particular implementation stands out. This particular implementation supports hierarchial inheritance and makes reasonable assumptions on the internal representations of primitive data types.
\texttt{xsd-parser-rs} by \texttt{Lumeo}, was created for use in their \texttt{Open Network Video Interface Forum Client}, software with requirements not dissimilar from that of IEEE 2030.5.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[derive(Default, PartialEq, Debug, YaSerialize, YaDeserialize)]
            #[yaserde(namespace = "urn:ieee:std:2030.5:ns")]
            pub struct List {
                // The number specifying "all" of the items in the list. 
                // Required on a response to a GET, ignored otherwise.
                #[yaserde(attribute, rename = "all")]
                pub all: Uint32,
            
                // Indicates the number of items in this page of results.
                #[yaserde(attribute, rename = "results")]
                pub results: Uint32,
            
                // A reference to the resource address (URI). 
                // Required in a response to a GET, ignored otherwise.
                #[yaserde(attribute, rename = "href")]
                pub href: Option<String>,
            }
        \end{lstlisting}
        \label{fig:listinher}
        \caption{A Rust data type representing an IEEE 2030.5 \texttt{List} as generated by \texttt{xsd-parser-rs}}
    \end{center}
\end{figure}

Figure 5.5 is what \texttt{xsd-parser-rs} currently produces. In this figure, it's parsed that the List type inherits from the Resource type, and included the href data member accordingly. It's also included the documentation as found in the schema.

Compared to true OOP inheritance, this has types include their parent type data members in their own type definitions.
Despite this, the type definitions are far more readable, and align more closely with the output of the client, in that inheritance is, as expected, flattened out.


\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            <List xmlns="urn:ieee:std:2030.5:ns" all="0" results=0" 
            href="/sample/list/uri" />
        \end{lstlisting}
        \label{fig:listinher}
        \caption{An XML representation of an IEEE 2030.5 \texttt{List} data type}
    \end{center}
\end{figure}

Figure 5.6 shows the List data type were it a concrete data type serialized into XML.

Further advocating for the use of an XSD parser is the fact that the 2030.5 XSD is updated more often than revisions of the specification itself, even if those updates are relatively infrequent.
Using \texttt{xsd-parser-rs} will allow us to better maintain the client, by way of simply running updated schemas through the parser.

Regrettably, \texttt{xsd-parser-rs} does not perfectly fit our needs:
\begin{itemize}
    \item It currently does not auto-generate Rust enums, since types where a rust enum would be best suited simply have their variants as comments in the XSD itself.
    \item It currently doesn't create and implement traits for us using base types, therefore, no polymorphism.
\end{itemize}

For that reason, as part of our client implementation, we'll be maintaining a git fork of the tool and will be implementing this functionality as required.


\subsection{Resource Serialisation \& Deserialisation}
As we've established, resources are sent as their XML representations over HTTP. This means our common library requires the ability to serialize and deserialize resources to and from the appropriate XML.


\subsection{Security}
The security-focused portion of the common library includes certificate management, and an encryption interface for use in client networking.
The specification requires that ECC, as defined in IETF RFC 7251, specifically elliptic curve \texttt{secp256r1}, be used to sign certificates and encrypt traffic over TLS 
However, the specification does permit RSA-based cipher suites to be used as a fallback, for the purpose of backwards compatibility, on devices where ECC is not supported.
For that reason, our common library will implement a security interface to be used throughout the client and server, such that it is comprehensive and can be replaced for portability.
\subsection{Network}
The network-focused portion of the common library includes creating and sending HTTP requests over TCP, whilst using the previously defined security interface for TLS.

It's worth noting that the extent to which a server implementation would utilise this interface is yet to be determined.


\subsection{Testing}



\section{Client Library}

\subsection{Server Discovery \& Connection}

\subsection{Event-driven Architecture}

\subsection{Function Sets}

\subsection{Testing}










\chapter{Implementation Design}\label{ch:implementation}
Given the context and background surrounding the IEEE 2030.5 Protocol, we can begin examining the considerations taken when designing our implementation.

\section{Programming Language}
The operating context of IEEE 2030.5 greatly influences the software development tools that are suitable for implementation.
When choosing a programming language, we must consider:

\begin{itemize}
    \item \textbf{Device resource constraints} - Many existing IEEE 2030.5 compliant devices are constrained by the clockspeed of the onboard CPU, and the amount of onboard memory.
    For example, the "Gen5 Riva" smart meter by Itron, possesses a 600Mhz processor, and 256Mb of RAM.\cite[]{Gen5Riva}
    \hfill \break
    Therefore, we desire a programming language with minimal runtime overhead, and low-cost abstractions.
    \item \textbf{Cross-platform capabilities} - Given that our client may be deployed on embedded hardware, writing code in a language that can be compiled to a wider range of CPU and hardware configurations is desirable. 
    For this reason, we saw EPRI choose to implement their client in the C programming language.
    \item \textbf{Security} - In 2019, Microsoft attributed 70\% of all CVEs in software to be caused by memory safety issues, in the last 12 years. \cite[]{SecurityMemorySafety}
    As we've previously established improving the security of end user energy devices is part of the core rationale behind IEEE 2030.5. For that reason, developing our client in a language that is memory safe would work towards this goal.
    \item \textbf{Concurrent programming support} - By nature of the protocol, an IEEE 2030.5 client is an I/O bound application. For that reason, we desire a programming language that provides us with abstractions for event-driven architecture, such that operations can be performed while waiting on I/O, even on a single threaded device.
\end{itemize}


\subsection{Rust}
The Rust programming language is a high-level, general purpose programming language that has been strongly influenced by the successes of other programming languages, both industrial and academic
Rust will be used to develop our IEEE 2030.5 client implementation as it addresses all the aforementioned considerations.

\begin{itemize}
    \item Rust provides us with high-level abstractions, but with a focus on performance, and only 'paying' (in terms of available computer resources) for what you use. For that reason, Rust has seen usage in both application and systems level programming.
    \item Although Rust is by no means a universal programming language like C, it has a growing presence in embedded development, and as such has a reasonable degree of portability.
    \item While writing a variation of Rust called 'safe' Rust, the programming language is, outside of compiler bugs, completely memory safe, without the runtime overhead of a garbage collector. When writing 'unsafe' rust, raw pointers may be dereferenced, where by the compiler is no longer able to guarantee memory safety. For that reason, our implementation will be done using purely safe Rust.
    \item Through it's type system, Rust also eliminates the possibility of a data race when working with multiple threads of execution. Furthermore, Rust has native support for asynchronous programming, with concurrency-runtime-independent await and async syntax.
\end{itemize}

Rust's high-level abstractions furthermore lend themselves to the imposed reliability of the client, in that all expected errors are to be handled at compile-time. The Rust algebraic sum types 'Option' and 'Result' enable programmers to handle errors, in order to use the output of a process.
This is contrasted to a language like C++, where runtime exceptions are used to denote errors in the standard library, of which the language does not force the programmer to handle at compile-time.

\section{Operating System}
Despite the desire to write code that is portable, we will nonetheless require operating-system-specific functionality, and as such will need to target a single operating system. Then, we can provide an interface for device manufacturers to swap out should they want to use the client on a different operating system.

Of great consideration when choosing an operating system is the aforementioned 'Aggregator' model for IEEE 2030.5, where by our client would be deployed on a dedicated server, or in the cloud. In this circumstance, it's very much likely an operating system running on the Linux kernel is to be used, due to it's prevalence in server operating-systems.
Whilst there exist purpose built IOT-device operating systems, they are built and optimised for low-spec low-power usage devices, and as such would not be appropriate at scale such as under this model.

Furthermore, there exist very lightweight Linux based operating systems for low-spec devices, making Linux the best choice for our targeted operating system.

\section{Common Library}
As discussed, the IEEE 2030.5 specification makes no distinction between clients \& servers, aside from the fact that servers expose resources, and clients interact with resources. 
For that reason, our client implementation will also produce a common library, that would be used one by developing a IEEE 2030.5 server implementation in Rust.

In this context, it's reasonable to draw inspiration from the EPRI implementation of an IEEE 2030.5 client, and define a series of interfaces that make use of OS specific APIs, such that a device manufacturer need only re-implement those interfaces when porting our software to a different OS.

\subsection{Resource Data Types}
The most important, and largest part of this common library is the internal representation of resources, the data communicated between client \& server. These resources are described precisely in an XSD.
Resources range from data that may be used by the electric utility, such as the current load of the device, to resource metadata, such as the rate at which a client should poll a server for a given resource, or what URI endpoint can be used to access a given resource, in the case of a Link resource.
In both specification and schema, these data structures are separated into packages, and sub-packages. 

Whilst the 2030.5 specification makes no mention of the object oriented programming paradigm, OOP inheritance underpins the design of all resources, including both multi-level and hierarchial inheritance.
As such, for the purpose of code reuse, many base types appear in the 'common' package; data structures extended by many others.

\subsubsection{Representing in Rust}
Rust, despite being influenced by OOP, does not have the notion of a class, like in languages like C++ or Java, and as such does not define shared behaviour of types through inheritance from a common parent type. 
Rather, Rust defines shared behaviour through traits, where shared behaviour refers solely to the methods that we can call on that type, as per the traits a type implements.
In this sense, Rust does not concern itself with what a type is or what that type stores, it concerns itself only with the traits a type possesses.

Traits themselves do support inheritance. One can have traits that require other traits to be implemented for a given type. However, this does not change the fact that traits only represent behaviour. 
There is no wa to have a data structure inherit the internal members of another.






\subsection{Resource Serialisation \& Deserialisation}
As we've established, resources are sent as their XML representations over HTTP. This means our common library requires the ability to serialize and deserialize resources to and from the appropriate XML.


\subsection{Security}
The security-focused portion of the common library includes certificate management, and an encryption interface for use in client networking.
The specification requires that ECC, as defined in IETF RFC 7251, specifically elliptic curve secp256r1, be used to sign certificates and encrypt traffic over TLS 
However, the specification does permit RSA-based cipher suites to be used as a fallback, for the purpose of backwards compatibility, on devices where ECC is not supported.
For that reason, our common library will implement a security interface to be used throughout the client and server, such that it is comprehensive and can be replaced for portability.
\subsection{Network}
The network-focused portion of the common library includes creating and sending HTTP requests over TCP, whilst using the previously defined security interface for TLS.

It's worth noting that the extent to which a server would utilise this interface is yet to be determined.


\subsection{Testing}



\section{Client Library}

\subsection{Server Discovery \& Connection}

\subsection{Event-driven Architecture}

\subsection{Function Sets}

\subsection{Testing}









